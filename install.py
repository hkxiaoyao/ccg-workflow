#!/usr/bin/env python3
"""
Skills-v2 å®‰è£…å™¨
Claude Code å¤šæ¨¡å‹åä½œç³»ç»Ÿ

ç”¨æ³•:
    python install.py                    # å®‰è£…æ ¸å¿ƒæ¨¡å—ï¼ˆé»˜è®¤ï¼‰
    python install.py --module core      # å®‰è£…æ ¸å¿ƒæ¨¡å—
    python install.py --module all       # å®‰è£…æ‰€æœ‰å¯ç”¨çš„æ¨¡å—
    python install.py --list-modules     # åˆ—å‡ºå¯ç”¨æ¨¡å—
    python install.py --install-dir ~/.claude  # è‡ªå®šä¹‰å®‰è£…ç›®å½•
"""

from __future__ import annotations

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

DEFAULT_INSTALL_DIR = "~/.claude"
DEFAULT_CONFIG = "config.json"

# æ£€æµ‹æ“ä½œç³»ç»Ÿ
IS_WINDOWS = platform.system() == "Windows"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Skills-v2 å®‰è£…å™¨ - å¤šæ¨¡å‹åä½œç³»ç»Ÿ"
    )
    parser.add_argument(
        "--install-dir",
        default=DEFAULT_INSTALL_DIR,
        help=f"å®‰è£…ç›®å½•ï¼ˆé»˜è®¤: {DEFAULT_INSTALL_DIR}ï¼‰",
    )
    parser.add_argument(
        "--module",
        default="core",
        help="è¦å®‰è£…çš„æ¨¡å—: 'core', 'codex-only', 'gemini-only', æˆ– 'all'",
    )
    parser.add_argument(
        "--config",
        default=DEFAULT_CONFIG,
        help="é…ç½®æ–‡ä»¶è·¯å¾„",
    )
    parser.add_argument(
        "--list-modules",
        action="store_true",
        help="åˆ—å‡ºå¯ç”¨æ¨¡å—å¹¶é€€å‡º",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="å¼ºåˆ¶è¦†ç›–ç°æœ‰æ–‡ä»¶",
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="æ˜¾ç¤ºè¯¦ç»†è¾“å‡º",
    )
    return parser.parse_args()


def load_config(config_path: str) -> Dict[str, Any]:
    path = Path(config_path)
    if not path.exists():
        print(f"é”™è¯¯: é…ç½®æ–‡ä»¶æœªæ‰¾åˆ°: {config_path}", file=sys.stderr)
        sys.exit(1)

    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def list_modules(config: Dict[str, Any]) -> None:
    print("\nğŸ“¦ å¯ç”¨æ¨¡å—:\n")
    modules = config.get("modules", {})
    for name, module in modules.items():
        status = "âœ… å·²å¯ç”¨" if module.get("enabled", False) else "âšª æœªå¯ç”¨"
        desc = module.get("description", "æ— æè¿°")
        print(f"  {name:15} {status:12} - {desc}")
    print()


def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def copy_file(src: Path, dst: Path, verbose: bool = False) -> None:
    ensure_dir(dst.parent)
    shutil.copy2(src, dst)
    if verbose:
        print(f"  ğŸ“„ å·²å¤åˆ¶: {src.name} -> {dst}")


def copy_dir(src: Path, dst: Path, verbose: bool = False) -> None:
    if dst.exists():
        shutil.rmtree(dst)
    shutil.copytree(src, dst)
    if verbose:
        print(f"  ğŸ“ å·²å¤åˆ¶ç›®å½•: {src.name} -> {dst}")


def merge_dir(src: Path, dst: Path, verbose: bool = False) -> None:
    ensure_dir(dst)
    for item in src.iterdir():
        dst_item = dst / item.name
        if item.is_file():
            shutil.copy2(item, dst_item)
            if verbose:
                print(f"  ğŸ“„ å·²åˆå¹¶: {item.name}")
        elif item.is_dir():
            if dst_item.exists():
                merge_dir(item, dst_item, verbose)
            else:
                shutil.copytree(item, dst_item)
                if verbose:
                    print(f"  ğŸ“ å·²åˆå¹¶ç›®å½•: {item.name}")


def check_go_installed() -> bool:
    try:
        result = subprocess.run(
            ["go", "version"],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def check_npm_installed() -> bool:
    """æ£€æŸ¥ npm æ˜¯å¦å·²å®‰è£…"""
    try:
        result = subprocess.run(
            ["npm", "--version"],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def choose_mcp_provider() -> Optional[str]:
    """
    è®©ç”¨æˆ·é€‰æ‹© MCP æä¾›å•†
    è¿”å›: "ace-tool" | "auggie" | None (è·³è¿‡)
    """
    print("\n" + "=" * 60)
    print("ğŸ”§ MCP ä»£ç æ£€ç´¢å·¥å…·é€‰æ‹©")
    print("=" * 60)
    print("\nè¯·é€‰æ‹©è¦å®‰è£…çš„ MCP å·¥å…·ï¼š\n")

    print("  [1] ace-tool (æ¨è)")
    print("      â€¢ ç¬¬ä¸‰æ–¹å°è£…ç‰ˆæœ¬ï¼Œä½¿ç”¨æ›´ç®€å•")
    print("      â€¢ âœ… å†…ç½® Prompt å¢å¼ºå·¥å…· (enhance_prompt)")
    print("      â€¢ âœ… ä»£ç åº“ä¸Šä¸‹æ–‡æ£€ç´¢ (search_context)")
    print("      â€¢ éœ€è¦æ³¨å†Œè·å– API Token: https://augmentcode.com/")
    print()

    print("  [2] auggie (å®˜æ–¹åŸç‰ˆ)")
    print("      â€¢ Augment å®˜æ–¹ MCP (@augmentcode/auggie)")
    print("      â€¢ âš ï¸  ä¸åŒ…å« Prompt å¢å¼ºå·¥å…·")
    print("      â€¢ âœ… ä»£ç åº“ä¸Šä¸‹æ–‡æ£€ç´¢ (codebase-retrieval)")
    print("      â€¢ ğŸ“– é…ç½®è¯´æ˜: https://linux.do/t/topic/1280612")
    print()

    print("  [0] è·³è¿‡ MCP å®‰è£… (ç¨åæ‰‹åŠ¨é…ç½®)")
    print()

    while True:
        choice = input("è¯·è¾“å…¥é€‰é¡¹ [1/2/0]: ").strip()
        if choice == "1":
            return "ace-tool"
        elif choice == "2":
            return "auggie"
        elif choice == "0":
            print("  â„¹ï¸  è·³è¿‡ MCP å®‰è£…ï¼Œç¨åå¯æ‰‹åŠ¨é…ç½®")
            return None
        else:
            print("  âŒ æ— æ•ˆé€‰é¡¹ï¼Œè¯·è¾“å…¥ 1ã€2 æˆ– 0")


def install_ace_tool(verbose: bool = False) -> Tuple[bool, str]:
    """
    å®‰è£…å¹¶é…ç½® ace-tool MCP
    è¿”å› (æˆåŠŸ, æ¶ˆæ¯)

    é‡è¦: Claude Code CLI ä» ~/.claude.json è¯»å– MCP é…ç½®
          NOT ~/.mcp.json (é‚£æ˜¯ç»™ Claude Desktop çš„)
          NOT ~/Library/Application Support/Claude/ (é‚£ä¹Ÿæ˜¯ Claude Desktop)
    """
    print("\n  ğŸ”§ é…ç½® ace-tool MCP...")

    # æ£€æŸ¥ npm
    if not check_npm_installed():
        return False, "npm æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… Node.js: https://nodejs.org/"

    # æç¤ºç”¨æˆ·é…ç½®
    print("\n  ğŸ“‹ ace-tool éœ€è¦é…ç½® API è®¿é—®ä¿¡æ¯:")
    print("     è·å–æ–¹å¼: è®¿é—® https://augmentcode.com/ æ³¨å†Œå¹¶è·å– API Token")
    print()

    # è·å– base-url
    default_base_url = "https://api.augmentcode.com"
    base_url = input(f"  è¯·è¾“å…¥ Base URL (ç›´æ¥å›è½¦ä½¿ç”¨é»˜è®¤å€¼ {default_base_url}): ").strip()
    if not base_url:
        base_url = default_base_url

    # è·å– token
    token = input("  è¯·è¾“å…¥ API Token: ").strip()
    if not token:
        print("  âš ï¸  Token ä¸ºç©ºï¼Œç¨åå¯æ‰‹åŠ¨é…ç½®")
        token = ""

    # Claude Code CLI çš„é…ç½®æ–‡ä»¶è·¯å¾„: ~/.claude.json
    config_file = Path.home() / ".claude.json"

    # è¯»å–ç°æœ‰é…ç½®ï¼ˆé‡è¦ï¼šä¿ç•™æ‰€æœ‰å…¶ä»–å­—æ®µï¼ï¼‰
    existing_config = {}
    if config_file.exists():
        try:
            with config_file.open("r", encoding="utf-8") as f:
                existing_config = json.load(f)
        except json.JSONDecodeError as e:
            print(f"  âš ï¸  ~/.claude.json è§£æå¤±è´¥: {e}")
            print("  âš ï¸  è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼Œè·³è¿‡ MCP é…ç½®")
            return False, f"~/.claude.json è§£æå¤±è´¥: {e}"
        except Exception as e:
            print(f"  âš ï¸  è¯»å– ~/.claude.json å¤±è´¥: {e}")
            return False, f"è¯»å–é…ç½®å¤±è´¥: {e}"

    # ç¡®ä¿ mcpServers å­—æ®µå­˜åœ¨
    if "mcpServers" not in existing_config:
        existing_config["mcpServers"] = {}

    # æ·»åŠ æˆ–æ›´æ–° ace-tool é…ç½®ï¼ˆä½¿ç”¨ç¯å¢ƒå˜é‡æ–¹å¼ï¼Œæ›´å®‰å…¨ï¼‰
    existing_config["mcpServers"]["ace-tool"] = {
        "type": "stdio",
        "command": "npx",
        "args": ["-y", "ace-tool@latest"],
        "env": {
            "ACE_BASE_URL": base_url,
            "ACE_TOKEN": token
        }
    }

    # å†™å…¥é…ç½®ï¼ˆä¿ç•™æ‰€æœ‰å…¶ä»–å­—æ®µï¼‰
    try:
        with config_file.open("w", encoding="utf-8") as f:
            json.dump(existing_config, f, indent=2, ensure_ascii=False)
        if verbose:
            print(f"  ğŸ“„ å·²å†™å…¥é…ç½®: {config_file}")
    except Exception as e:
        return False, f"å†™å…¥é…ç½®å¤±è´¥: {e}"

    # æµ‹è¯•å®‰è£…
    print("\n  ğŸš€ éªŒè¯ ace-tool å®‰è£…...")
    try:
        result = subprocess.run(
            ["npx", "-y", "ace-tool@latest", "--version"],
            capture_output=True,
            text=True,
            timeout=60
        )
        if result.returncode == 0:
            version = result.stdout.strip() or "unknown"
            if verbose:
                print(f"  âœ… ace-tool ç‰ˆæœ¬: {version}")
        else:
            if verbose:
                print(f"  âš ï¸  ace-tool éªŒè¯å¤±è´¥ï¼Œä½†é…ç½®å·²ä¿å­˜")
    except subprocess.TimeoutExpired:
        print("  âš ï¸  éªŒè¯è¶…æ—¶ï¼Œä½†é…ç½®å·²ä¿å­˜")
    except Exception as e:
        if verbose:
            print(f"  âš ï¸  éªŒè¯å¼‚å¸¸: {e}")

    return True, f"ace-tool MCP é…ç½®å®Œæˆ: {config_file}"


def install_auggie(verbose: bool = False) -> Tuple[bool, str]:
    """
    å®‰è£…å¹¶é…ç½® auggie MCP (Augment å®˜æ–¹ç‰ˆæœ¬)
    è¿”å› (æˆåŠŸ, æ¶ˆæ¯)
    """
    print("\n  ğŸ”§ é…ç½® auggie MCP...")

    # æ£€æŸ¥ npm
    if not check_npm_installed():
        return False, "npm æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… Node.js: https://nodejs.org/"

    # æç¤ºç”¨æˆ·é…ç½®è¯´æ˜
    print("\n  ğŸ“– auggie é…ç½®è¯´æ˜:")
    print("     è¯¦ç»†é…ç½®æ•™ç¨‹: https://linux.do/t/topic/1280612")
    print("     è·å– API Token: è®¿é—® https://augmentcode.com/ æ³¨å†Œ")
    print()
    print("  âš ï¸  æ³¨æ„: auggie ä¸åŒ…å« Prompt å¢å¼ºå·¥å…·")
    print("     å¦‚éœ€ä½¿ç”¨ Prompt å¢å¼ºï¼Œè¯·æŸ¥çœ‹ä¸Šè¿°æ•™ç¨‹æ‰‹åŠ¨é…ç½®")
    print()

    # å®‰è£… auggie
    print("  ğŸš€ å®‰è£… @augmentcode/auggie@prerelease...")
    try:
        result = subprocess.run(
            ["npm", "install", "-g", "@augmentcode/auggie@prerelease"],
            capture_output=True,
            text=True,
            timeout=120
        )
        if result.returncode != 0:
            return False, f"npm å®‰è£…å¤±è´¥: {result.stderr}"
        if verbose:
            print(f"  âœ… auggie å®‰è£…æˆåŠŸ")
    except subprocess.TimeoutExpired:
        return False, "å®‰è£…è¶…æ—¶"
    except Exception as e:
        return False, f"å®‰è£…å¼‚å¸¸: {e}"

    # è·å– token
    print("\n  è¯·è¾“å…¥ API Token (ä» https://augmentcode.com/ è·å–):")
    token = input("  Token: ").strip()
    if not token:
        print("  âš ï¸  Token ä¸ºç©ºï¼Œç¨åå¯æ‰‹åŠ¨é…ç½®")
        token = ""

    # Claude Code CLI çš„é…ç½®æ–‡ä»¶è·¯å¾„: ~/.claude.json
    config_file = Path.home() / ".claude.json"

    # è¯»å–ç°æœ‰é…ç½®
    existing_config = {}
    if config_file.exists():
        try:
            with config_file.open("r", encoding="utf-8") as f:
                existing_config = json.load(f)
        except json.JSONDecodeError as e:
            print(f"  âš ï¸  ~/.claude.json è§£æå¤±è´¥: {e}")
            return False, f"~/.claude.json è§£æå¤±è´¥: {e}"
        except Exception as e:
            print(f"  âš ï¸  è¯»å– ~/.claude.json å¤±è´¥: {e}")
            return False, f"è¯»å–é…ç½®å¤±è´¥: {e}"

    # ç¡®ä¿ mcpServers å­—æ®µå­˜åœ¨
    if "mcpServers" not in existing_config:
        existing_config["mcpServers"] = {}

    # æ·»åŠ æˆ–æ›´æ–° auggie é…ç½®
    existing_config["mcpServers"]["auggie-mcp"] = {
        "type": "stdio",
        "command": "auggie",
        "env": {
            "AUGMENT_API_KEY": token
        }
    }

    # å†™å…¥é…ç½®
    try:
        with config_file.open("w", encoding="utf-8") as f:
            json.dump(existing_config, f, indent=2, ensure_ascii=False)
        if verbose:
            print(f"  ğŸ“„ å·²å†™å…¥é…ç½®: {config_file}")
    except Exception as e:
        return False, f"å†™å…¥é…ç½®å¤±è´¥: {e}"

    print("\n  âœ… auggie MCP é…ç½®å®Œæˆ")
    print(f"  ğŸ“– è¯¦ç»†é…ç½®è¯´æ˜: https://linux.do/t/topic/1280612")

    return True, f"auggie MCP é…ç½®å®Œæˆ: {config_file}"


def create_ccg_config(mcp_provider: str, install_dir: Path, verbose: bool = False) -> bool:
    """
    åˆ›å»º ~/.ccg/config.toml é…ç½®æ–‡ä»¶

    Args:
        mcp_provider: "ace-tool" | "auggie" | "none"
        install_dir: å®‰è£…ç›®å½• (é€šå¸¸æ˜¯ ~/.claude)
        verbose: è¯¦ç»†è¾“å‡º

    Returns:
        æˆåŠŸä¸å¦
    """
    ccg_dir = Path.home() / ".ccg"
    config_file = ccg_dir / "config.toml"

    # ç¡®ä¿ç›®å½•å­˜åœ¨
    ensure_dir(ccg_dir)

    # ç”Ÿæˆé…ç½®å†…å®¹
    config_content = f"""# CCG (Claude + Codex + Gemini) å¤šæ¨¡å‹åä½œç³»ç»Ÿé…ç½®
# ç”Ÿæˆæ—¶é—´: {subprocess.run(['date'], capture_output=True, text=True).stdout.strip()}

[mcp]
# MCP æä¾›å•†: ace-tool | auggie | none
provider = "{mcp_provider}"

[mcp.tools]
# å·¥å…·åç§°æ˜ å°„ï¼ˆå‘½ä»¤æ¨¡æ¿ä¼šè‡ªåŠ¨è¯»å–æ­¤é…ç½®ï¼‰
# ä»£ç æ£€ç´¢å·¥å…·
code_search_ace = "mcp__ace-tool__search_context"
code_search_auggie = "mcp__auggie-mcp__codebase-retrieval"

# Prompt å¢å¼ºå·¥å…·
prompt_enhance_ace = "mcp__ace-tool__enhance_prompt"
prompt_enhance_auggie = ""  # auggie ä¸æ”¯æŒ

# å‚æ•°åç§°æ˜ å°„
query_param_ace = "query"
query_param_auggie = "information_request"

[mcp.ace-tool]
# ace-tool (ç¬¬ä¸‰æ–¹å°è£…) åŠŸèƒ½è¯´æ˜
features = ["Prompt å¢å¼º", "ä»£ç æ£€ç´¢"]
setup_url = "https://augmentcode.com/"

[mcp.auggie]
# auggie (å®˜æ–¹åŸç‰ˆ) åŠŸèƒ½è¯´æ˜
features = ["ä»£ç æ£€ç´¢"]
setup_url = "https://linux.do/t/topic/1280612"
note = "auggie ä¸åŒ…å« Prompt å¢å¼ºå·¥å…·ï¼Œéœ€æ‰‹åŠ¨é…ç½®"

[routing]
# è·¯ç”±æ¨¡å¼: smart | parallel | sequential
mode = "smart"

[routing.frontend]
# å‰ç«¯ä»»åŠ¡è·¯ç”±é…ç½®
models = ["gemini", "codex"]
primary = "gemini"
strategy = "parallel"

[routing.backend]
# åç«¯ä»»åŠ¡è·¯ç”±é…ç½®
models = ["codex", "gemini"]
primary = "codex"
strategy = "parallel"

[routing.review]
# ä»£ç å®¡æŸ¥è·¯ç”±é…ç½®
models = ["codex", "gemini"]
strategy = "parallel"
"""

    try:
        with config_file.open("w", encoding="utf-8") as f:
            f.write(config_content)
        if verbose:
            print(f"  ğŸ“„ å·²åˆ›å»ºé…ç½®: {config_file}")
        return True
    except Exception as e:
        print(f"  âš ï¸  åˆ›å»ºé…ç½®å¤±è´¥: {e}", file=sys.stderr)
        return False


def get_prebuilt_binary(source_dir: Path) -> Optional[Path]:
    """æŸ¥æ‰¾é¢„ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶"""
    system = platform.system().lower()
    machine = platform.machine().lower()

    # æ˜ å°„æ¶æ„åç§°
    arch_map = {
        "x86_64": "amd64",
        "amd64": "amd64",
        "arm64": "arm64",
        "aarch64": "arm64",
    }
    arch = arch_map.get(machine, machine)

    # æ˜ å°„ç³»ç»Ÿåç§°
    if system == "darwin":
        binary_name = f"codeagent-wrapper-darwin-{arch}"
    elif system == "linux":
        binary_name = f"codeagent-wrapper-linux-{arch}"
    elif system == "windows":
        binary_name = f"codeagent-wrapper-windows-{arch}.exe"
    else:
        return None

    binary_path = source_dir / "bin" / binary_name
    if binary_path.exists():
        return binary_path
    return None


def build_go_binary(
    source_dir: Path,
    binary_name: str,
    verbose: bool = False
) -> Tuple[bool, Optional[Path]]:
    if not check_go_installed():
        print("  âŒ Go æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… Go:", file=sys.stderr)
        print("     https://go.dev/doc/install", file=sys.stderr)
        return False, None

    # Windows æ·»åŠ  .exe æ‰©å±•å
    if IS_WINDOWS and not binary_name.endswith(".exe"):
        output_name = binary_name + ".exe"
    else:
        output_name = binary_name

    if verbose:
        print(f"  ğŸ”¨ æ­£åœ¨ç¼–è¯‘ {output_name}...")

    try:
        result = subprocess.run(
            ["go", "build", "-o", output_name, "."],
            cwd=source_dir,
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print(f"  âŒ ç¼–è¯‘å¤±è´¥: {result.stderr}", file=sys.stderr)
            return False, None

        binary_path = source_dir / output_name
        if not binary_path.exists():
            print(f"  âŒ ç¼–è¯‘åæœªæ‰¾åˆ°äºŒè¿›åˆ¶æ–‡ä»¶", file=sys.stderr)
            return False, None

        if verbose:
            print(f"  âœ… ç¼–è¯‘å®Œæˆ: {output_name}")

        return True, binary_path

    except Exception as e:
        print(f"  âŒ ç¼–è¯‘é”™è¯¯: {e}", file=sys.stderr)
        return False, None


def install_binary_to_path(
    binary_path: Path,
    verbose: bool = False,
    target_name: Optional[str] = None
) -> bool:
    # ç¡®å®šç›®æ ‡æ–‡ä»¶å
    if target_name:
        if IS_WINDOWS and not target_name.endswith(".exe"):
            final_name = target_name + ".exe"
        else:
            final_name = target_name
    else:
        final_name = binary_path.name

    # æ ¹æ®ç³»ç»Ÿé€‰æ‹©å®‰è£…ç›®å½•
    if IS_WINDOWS:
        install_dirs = [
            Path.home() / ".local" / "bin",
            Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "codeagent-wrapper",
            Path.home() / "bin",
        ]
    else:
        install_dirs = [
            Path.home() / ".local" / "bin",
            Path("/usr/local/bin"),
        ]

    for install_dir in install_dirs:
        if install_dir.exists() or install_dir == install_dirs[0]:
            try:
                ensure_dir(install_dir)
                target = install_dir / final_name
                shutil.copy2(binary_path, target)

                # è®¾ç½®æ‰§è¡Œæƒé™ï¼ˆä»… Unixï¼‰
                if not IS_WINDOWS:
                    os.chmod(target, 0o755)

                if verbose:
                    print(f"  ğŸ“¦ å·²å®‰è£…åˆ°: {target}")

                # æ£€æŸ¥å®‰è£…ç›®å½•æ˜¯å¦åœ¨ PATH ä¸­
                path_dirs = os.environ.get("PATH", "").split(os.pathsep)
                if str(install_dir) not in path_dirs:
                    print(f"  âš ï¸  æ³¨æ„: {install_dir} å¯èƒ½ä¸åœ¨ PATH ä¸­")
                    if IS_WINDOWS:
                        print(f"     æ·»åŠ åˆ° PATH: setx PATH \"%PATH%;{install_dir}\"")
                    else:
                        print(f"     æ·»åŠ åˆ° PATH: export PATH=\"{install_dir}:$PATH\"")

                return True
            except PermissionError:
                if verbose:
                    print(f"  âš ï¸  {install_dir} æƒé™ä¸è¶³ï¼Œå°è¯•ä¸‹ä¸€ä¸ª...")
                continue
            except Exception as e:
                if verbose:
                    print(f"  âš ï¸  å®‰è£…åˆ° {install_dir} å¤±è´¥: {e}")
                continue

    print("  âŒ æ— æ³•å®‰è£…äºŒè¿›åˆ¶æ–‡ä»¶åˆ° PATH", file=sys.stderr)
    if IS_WINDOWS:
        print(f"     æ‰‹åŠ¨å®‰è£…: å¤åˆ¶ {binary_path} åˆ° PATH ä¸­çš„ç›®å½•", file=sys.stderr)
    else:
        print(f"     æ‰‹åŠ¨å®‰è£…: sudo cp {binary_path} /usr/local/bin/", file=sys.stderr)
    return False


def execute_operation(
    op: Dict[str, Any],
    source_dir: Path,
    install_dir: Path,
    verbose: bool = False
) -> bool:
    op_type = op.get("type")
    source = op.get("source", "")
    target = op.get("target", source)
    desc = op.get("description", "")

    src_path = source_dir / source
    dst_path = install_dir / target

    if verbose:
        print(f"\n  ğŸ”§ {desc}")

    try:
        if op_type == "copy_file":
            if not src_path.exists():
                print(f"  âš ï¸  æºæ–‡ä»¶æœªæ‰¾åˆ°: {src_path}", file=sys.stderr)
                return False
            copy_file(src_path, dst_path, verbose)

        elif op_type == "copy_dir":
            if not src_path.exists():
                print(f"  âš ï¸  æºç›®å½•æœªæ‰¾åˆ°: {src_path}", file=sys.stderr)
                return False
            copy_dir(src_path, dst_path, verbose)

        elif op_type == "merge_dir":
            if not src_path.exists():
                print(f"  âš ï¸  æºç›®å½•æœªæ‰¾åˆ°: {src_path}", file=sys.stderr)
                return False
            merge_dir(src_path, dst_path, verbose)

        elif op_type == "build_go":
            binary_name = op.get("binary", "")

            # ä¼˜å…ˆä½¿ç”¨é¢„ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶
            prebuilt = get_prebuilt_binary(source_dir)
            if prebuilt:
                if verbose:
                    print(f"  ğŸ“¦ ä½¿ç”¨é¢„ç¼–è¯‘äºŒè¿›åˆ¶: {prebuilt.name}")
                # é‡å‘½åä¸ºç›®æ ‡åç§°
                target_name = binary_name
                if IS_WINDOWS and not target_name.endswith(".exe"):
                    target_name += ".exe"
                binary_path = prebuilt
            else:
                # æ²¡æœ‰é¢„ç¼–è¯‘äºŒè¿›åˆ¶ï¼Œå°è¯•ç¼–è¯‘
                if verbose:
                    print(f"  â„¹ï¸  æœªæ‰¾åˆ°é¢„ç¼–è¯‘äºŒè¿›åˆ¶ï¼Œå°è¯•ç¼–è¯‘...")
                if not src_path.exists():
                    print(f"  âš ï¸  æºç›®å½•æœªæ‰¾åˆ°: {src_path}", file=sys.stderr)
                    return False

                success, binary_path = build_go_binary(src_path, binary_name, verbose)
                if not success:
                    return False

            # å®‰è£…åˆ° PATH
            if not install_binary_to_path(binary_path, verbose, target_name=binary_name):
                return False

        elif op_type == "install_ace_tool":
            # å…¼å®¹æ—§é…ç½®ï¼Œç›´æ¥å®‰è£… ace-tool
            success, message = install_ace_tool(verbose)
            if not success:
                print(f"  âš ï¸  {message}")
                print(f"  â„¹ï¸  å¯ç¨åæ‰‹åŠ¨é…ç½® ace-tool MCP")
                return True  # ä¸é˜»æ­¢å…¶ä»–å®‰è£…
            if verbose:
                print(f"  â„¹ï¸  {message}")
            # åˆ›å»ºé…ç½®æ–‡ä»¶
            create_ccg_config("ace-tool", install_dir, verbose)

        elif op_type == "install_mcp":
            # åŠ¨æ€ MCP é€‰æ‹©
            mcp_provider = choose_mcp_provider()

            if mcp_provider is None:
                print("  âš ï¸  è·³è¿‡ MCP å®‰è£…")
                create_ccg_config("none", install_dir, verbose)
                return True  # ä¸é˜»æ­¢å…¶ä»–å®‰è£…

            # æ ¹æ®é€‰æ‹©å®‰è£…å¯¹åº”çš„ MCP
            if mcp_provider == "ace-tool":
                success, message = install_ace_tool(verbose)
            elif mcp_provider == "auggie":
                success, message = install_auggie(verbose)
            else:
                print(f"  âŒ æœªçŸ¥çš„ MCP æä¾›å•†: {mcp_provider}", file=sys.stderr)
                return False

            if not success:
                print(f"  âš ï¸  {message}")
                print(f"  â„¹ï¸  å¯ç¨åæ‰‹åŠ¨é…ç½® MCP")
                create_ccg_config("none", install_dir, verbose)
                return True  # ä¸é˜»æ­¢å…¶ä»–å®‰è£…

            if verbose:
                print(f"  â„¹ï¸  {message}")

            # åˆ›å»ºé…ç½®æ–‡ä»¶
            create_ccg_config(mcp_provider, install_dir, verbose)

        else:
            print(f"  âš ï¸  æœªçŸ¥æ“ä½œç±»å‹: {op_type}", file=sys.stderr)
            return False

        return True

    except Exception as e:
        print(f"  âŒ é”™è¯¯: {e}", file=sys.stderr)
        return False


def install_module(
    name: str,
    module: Dict[str, Any],
    source_dir: Path,
    install_dir: Path,
    verbose: bool = False
) -> bool:
    print(f"\nğŸ“¦ æ­£åœ¨å®‰è£…æ¨¡å—: {name}")
    print(f"   {module.get('description', '')}")

    operations = module.get("operations", [])
    success_count = 0

    for op in operations:
        if execute_operation(op, source_dir, install_dir, verbose):
            success_count += 1

    if success_count == len(operations):
        print(f"   âœ… æ¨¡å— '{name}' å®‰è£…æˆåŠŸ!")
        return True
    else:
        print(f"   âš ï¸  æ¨¡å— '{name}' å®‰è£…å®Œæˆï¼Œä½†æœ‰ {len(operations) - success_count} ä¸ªè­¦å‘Š")
        return False


def main() -> int:
    args = parse_args()

    # è§£æè·¯å¾„
    config_path = Path(args.config)
    if not config_path.is_absolute():
        config_path = Path(__file__).parent / args.config

    source_dir = config_path.parent
    install_dir = Path(args.install_dir).expanduser().resolve()

    # åŠ è½½é…ç½®
    config = load_config(str(config_path))

    # åˆ—å‡ºæ¨¡å—æ¨¡å¼
    if args.list_modules:
        list_modules(config)
        return 0

    # æ‰“å°æ ‡é¢˜
    print("\n" + "=" * 50)
    print("ğŸš€ Skills-v2 å®‰è£…å™¨")
    print("   å¤šæ¨¡å‹åä½œç³»ç»Ÿ")
    print("=" * 50)
    print(f"\nğŸ“ å®‰è£…ç›®å½•: {install_dir}")

    # ç¡®ä¿å®‰è£…ç›®å½•å­˜åœ¨
    ensure_dir(install_dir)

    # ç¡®å®šè¦å®‰è£…çš„æ¨¡å—
    modules = config.get("modules", {})
    modules_to_install = []

    if args.module == "all":
        modules_to_install = [
            (name, mod) for name, mod in modules.items()
            if mod.get("enabled", False)
        ]
    elif args.module in modules:
        modules_to_install = [(args.module, modules[args.module])]
    else:
        print(f"\nâŒ æœªçŸ¥æ¨¡å—: {args.module}", file=sys.stderr)
        print("   ä½¿ç”¨ --list-modules æŸ¥çœ‹å¯ç”¨æ¨¡å—")
        return 1

    if not modules_to_install:
        print("\nâš ï¸  æ²¡æœ‰å¯å®‰è£…çš„æ¨¡å—")
        return 0

    # å®‰è£…æ¨¡å—
    success = True
    for name, module in modules_to_install:
        if not install_module(name, module, source_dir, install_dir, args.verbose):
            success = False

    # æ‰“å°æ‘˜è¦
    print("\n" + "=" * 50)
    if success:
        print("âœ… å®‰è£…å®Œæˆ!")
        print("\nğŸ“‹ å·²å®‰è£…å‘½ä»¤ (/ccg:xxx):")
        print("   å¼€å‘å·¥ä½œæµ:")
        print("     /ccg:dev       - å®Œæ•´6é˜¶æ®µå¤šæ¨¡å‹å·¥ä½œæµ")
        print("     /ccg:code      - å¤šæ¨¡å‹ä»£ç ç”Ÿæˆï¼ˆæ™ºèƒ½è·¯ç”±ï¼‰")
        print("     /ccg:debug     - UltraThink å¤šæ¨¡å‹è°ƒè¯•")
        print("     /ccg:test      - å¤šæ¨¡å‹æµ‹è¯•ç”Ÿæˆ")
        print("     /ccg:bugfix    - è´¨é‡é—¨æ§ä¿®å¤ï¼ˆ90%+ é€šè¿‡ï¼‰")
        print("     /ccg:think     - æ·±åº¦åˆ†æ")
        print("     /ccg:optimize  - æ€§èƒ½ä¼˜åŒ–")
        print("     /ccg:frontend  - å‰ç«¯ä»»åŠ¡ â†’ Gemini")
        print("     /ccg:backend   - åç«¯ä»»åŠ¡ â†’ Codex")
        print("     /ccg:review    - åŒæ¨¡å‹ä»£ç å®¡æŸ¥")
        print("     /ccg:analyze   - åŒæ¨¡å‹åˆ†æ")
        print("     /ccg:enhance   - Prompt å¢å¼º")
        print("   Git å·¥å…·:")
        print("     /ccg:commit         - æ™ºèƒ½æäº¤")
        print("     /ccg:rollback       - äº¤äº’å¼å›æ»š")
        print("     /ccg:clean-branches - æ¸…ç†åˆ†æ”¯")
        print("     /ccg:worktree       - Worktree ç®¡ç†")
        print("   é¡¹ç›®åˆå§‹åŒ–:")
        print("     /ccg:init      - åˆå§‹åŒ–é¡¹ç›® AI ä¸Šä¸‹æ–‡")
        print("\nğŸ¯ å¿«é€Ÿå¼€å§‹:")
        print('   /ccg:dev "å®ç°ç”¨æˆ·è®¤è¯åŠŸèƒ½"')
        print('   /ccg:debug "ç™»å½•æ¥å£è¿”å›500é”™è¯¯"')
        print('   /ccg:bugfix "å¯†ç é‡ç½®å¤±è´¥"')
    else:
        print("âš ï¸  å®‰è£…å®Œæˆï¼Œä½†æœ‰è­¦å‘Š")
    print("=" * 50 + "\n")

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
